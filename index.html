---
layout: home 
title: Portal for Java 
---
<div class="row">
    <div class="large-12 columns main">
    	<h1>Getting Started <small>v0.9.0</small></h1>
        <p>The <strong>Portal for Java</strong> is a server implementation of the <a href="http://flowersinthesand.github.io/portal">Portal</a> written in Java, JavaScript library for real-time web application development.</p>
        <hr />
        <h2></h2>
        <h2>Installing</h2>
        <p>Portal for Java is distributed through <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.github.flowersinthesand%22%20AND%20a%3A%22portal%22">Maven Central</a>, only one artifact: <code>io.github.flowersinthesand:portal:0.9.0</code> and is a server-side wes application so that it can run on any framework wes supports. See <a href="http://flowersinthesand.github.io/wes">wes</a> documentation for what frameworks are supported and how to install portal on them. The following example shows how to install a portal server in Java Servlet with the help of Atmosphere framework.</p>
{% capture panel %}
```java
@WebListener
public class Bootstrap implements ServletContextListener {
    
    @Override
    public void contextInitialized(ServletContextEvent event) {
        // Create a portal server
        Server server = new DefaultServer();
        
        // Adds a socket action
        server.socketAction(new Action<Socket>() {
            @Override
            public void on(final Socket socket) {
                socket.on("echo", new Action<Object>() {
                    @Override
                    public void on(Object data) {
                        socket.send("echo", data);
                    }
                });
            }
        });
        
        // Install server by specifying path and attaching its wes actions to wes bridge
        new AtmosphereBridge(event.getServletContext(), "/test").httpAction(server.httpAction()).websocketAction(server.websocketAction());
    }
    
    @Override
    public void contextDestroyed(ServletContextEvent sce) {}
    
}
```
{% endcapture %}{{ panel | markdownify }}
        <hr />
        <h2>API</h2>
        <p>Let's take a brief look at API usage.</p>
        <h3><a href="{{ site.baseurl }}/0.9.0/api/io/github/flowersinthesand/portal/Server.html">Server</a></h3>
        <p>Server provides and manages socket processing HTTP message and WebSocket.</p>
        <h4>Handling Socket</h4>
        <p>When a socket is opened, actions added via <code>socketAction</code> are executed with it. It's allowed to add several actions before and after installation, so you don't need to centralize all your code to one class.</p>
{% capture panel %}
```java
server.socketAction(new Action<Socket>() {
    @Override
    public void on(Socket socket) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <h4>Selecting Sockets</h4>
        <p>It's a common use case to select some sockets and do something with them like dealing with persistence entity or HTML elements. When a socket has been closed, it is evicted from the server, so socket being passed to action is always in open state where I/O operations are available.</p>
        <h5>All</h5>
        <p><code>all</code> executes the given action finding all of the socket in this server.</p>
{% capture panel %}
```java
server.all(new Action<Socket>() {
    @Override
    public void on(Socket socket) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <h5>By Id</h5>
        <p>Every socket has a unique id. <code>byId</code> finds socket by id and executes the given action only once or not if no socket is found.</p>
{% capture panel %}
```java
server.byId("59f3e826-3684-4e0e-813d-8394ac7fb7c0", new Action<Socket>() {
    @Override
    public void on(Socket socket) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <h5>By Tag</h5>
        <p>A socket may have several tags and a tag may have several sockets like many-to-many relationship. <code>byTag</code> find socket accepting one or more tag names and executes the given action. It is desirable to use tag when dealing with a specific concept in the real world (e.g. person and topic). Tag set is managed only by server and unknown to client.</p>
{% capture panel %}
```java
server.byTag("room#201", new Action<Socket>() {
    @Override
    public void on(Socket socket) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <h4>Writing Sentence</h4>
        <p><code>Sentence</code> is a series of predicates that a group of sockets have to follow. Finder methods return a sentence when being called without action. Use of sentence is preferred to that of action if the goal is same. Because, it enables to write one-liner action and uses an action implementing <code>Serializable</code> in execution, which is picky to use in anonymous class and typically needed in clustering.</p>
{% capture panel %}
```java
server.all().send("foo", "bar");
```
```java
server.byTag("room#201").send("message", "time to say goodbye").close();
```
{% endcapture %}{{ panel | markdownify }}
        <h3><a href="{{ site.baseurl }}/0.9.0/api/io/github/flowersinthesand/portal/Server.html">Socket</a></h3>
        <p>Socket is a connectivity between the two portal endpoints where event occurs. Do not hold a reference on socket unless the reference shares the same life cycle of socket. It makes things complicated since it is stateful and also may result in a problem in clustered environment. Always create a socket action and pass it to server to access socket.</p>
        <h4>Properties</h4>
        <p>These are read only.</p>
        <div class="row">
            <div class="large-4 columns">
                <h5>Id</h5>
                <p>A unique identifier in the form of UUID generated by client by default.</p>
{% capture panel %}
```java
socket.id();
```
        {% endcapture %}{{ panel | markdownify }}
            </div>
            <div class="large-4 columns">
                <h5>URI</h5>
                <p>A URI used to connect. To work with URI parts, use <code>java.net.URI</code> or something like that.</p>
{% capture panel %}
```java
URI.create(socket.uri()).getQuery();
```
{% endcapture %}{{ panel | markdownify }}
            </div>
            <div class="large-4 columns">
                <h5>Tags</h5>
                <p>A set of tag names. It's modifiable, deal with it as a plain set.</p>
{% capture panel %}
```java
Set<String> tags = socket.tags();
tags.add("account#flowersinthesand");
```
{% endcapture %}{{ panel | markdownify }}
            </div>
        </div>
        <h4>Receiving Events</h4>
        <p><code>on</code> attaches an event handler. Allowed <a href="{{ site.baseurl }}/0.9.0/api/io/github/flowersinthesand/portal/Socket.html#on(java.lang.String, io.github.flowersinthesand.wes.Action)">Java types</a> for data corresponding to JSON types. As reserved event, when a socket has been closed, <code>close</code> event is fired without data.</p>
{% capture panel %}
```java
socket.on("event", new Action<Map<String, Object>>() {
    @Override
    public void on(Map<String, Object> object) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <p>In the case where client sends an event with callback like Remote Procedure Call, you can handle it using <code>Reply</code> in an asynchronous manner.</p>
{% capture panel %}
```java
socket.on("account:findById", new Action<Reply<String>>() {
    @Override
    public void on(Reply<String> reply) {
        try {
            reply.done(Account.find.byId(reply.data()));
        } catch(EntityNotFoundException e) {
            reply.fail();
        }
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <h4>Sending Events</h4>
        <p><code>send</code> sends an event with or without data. Unlike when receiving event, when sending event you can use any type of data and it will be stringified by Jackson. Don't rely on features of Jackson too much, i.e. annotation. There is no restriction on event name but to avoid confusion don't use <code>connecting</code>, <code>waiting</code>, <code>open</code> and <code>close</code> as event name, which are reserved event in client.</p>
{% capture panel %}
```java
socket.send("event").send("event", "data");
```
{% endcapture %}{{ panel | markdownify }}
        <p>Server also can send an event with callback to client as Remote Procedure Call. Allowed Java types are the same when action added via <code>on</code> receives data.</p>
{% capture panel %}
```java
socket.send("event", "data", new Action<Object>() {
    @Override
    public void on(Object result) {
        // Your logic here
    }
});
```
{% endcapture %}{{ panel | markdownify }}
        <hr />
        <h2>Test Suite</h2>
        <p>Portal for Java provides a server for Portal test suite. It's available on <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.github.flowersinthesand%22%20AND%20a%3A%22portal-testsuite%22">Maven Central</a>. This module's a goal is to provide a complete form of test suite in Java and it will be done as soon as wes starts to support client-side frameworks.</p>
        <p>With that server, you can test your client implementation. It comes with <a href="https://github.com/flowersinthesand/portal/tree/master/test/webapp">test suite</a> from the portal repository so you can see how Portal for Java passes the test suite in your browser. For how to start the server, see <a href="{{ site.baseurl }}/0.9.0/api/io/github/flowersinthesand/portal/testsuite/ServerBootstrap.html">ServerBootstrap</a>.</p>
        <hr />
        <h2>Examples</h2>
        <p>The followings are brief introduction of <a href="https://github.com/flowersinthesand/portal-java-examples/">working example applications</a>.</p>
        <h3>Platform</h3>
        <p>Portal for Java is an embeddable web application built on top of <a href="http://flowersinthesand.github.io/wes">wes</a> and it can run on as many platform as wes supports.</p>
		<ul class="inline-list">
			<li><a href="https://github.com/flowersinthesand/portal-java-examples/tree/master/server/platform/atmosphere2">Atmosphere 2</a></li>
			<li><a href="https://github.com/flowersinthesand/portal-java-examples/tree/master/server/platform/vertx2">Vert.x 2</a></li>
			<li><a href="https://github.com/flowersinthesand/portal-java-examples/tree/master/server/platform/jee7">Servlet 3 and Java WebSocket API 1</a></li>
		</ul>
        <h3>Clustering</h3>
        <p><code>ClusteredServer</code> follows the publish and subscribe model to support clustering. All of the message oriented middleware supporting that model can be used to cluster multiple Portal for Java applications.</p>
		<ul class="inline-list">
			<li><a href="https://github.com/flowersinthesand/portal-java-examples/tree/master/server/clustering/hazelcast">Hazelcast 3</a></li>
		</ul>
        <h3>Dependency Injection</h3>
        <p>With dependency injection support by framework or container, you can make <code>Server</code> as component and inject it wherever you need to handle sockets cleanly without static keyword.</p>
		<ul class="inline-list">
			<li><a href="https://github.com/flowersinthesand/portal-java-examples/tree/master/server/di/spring">Spring</a></li>
		</ul>
        <h3>Data Type Conversion</h3>
        <p>The corresponding Java type of JSON object is <code>Map&lt;String, Object&gt;</code> that probably is the most used type to receive event data. If you want to convert Map to Java bean, there are many ways you can try. e.g. reflection and serialization.</p>
        
		<ul class="inline-list">
			<li><a href="https://gist.github.com/flowersinthesand/8486640">Jackson</a></li>
		</ul>
    </div>
</div>